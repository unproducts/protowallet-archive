import later, { ScheduleData } from '@breejs/later';
import feed from '../feeds';
import { Range, RecurringTransaction, Transaction } from '../lookups';
import { EndRecurrenceBy, RecordType } from '../lookups/enums';
import { generateRandomStringOfLength } from '../utils';
import { assertAccountExists } from './accounts';

export type GetAllTransactionsOptions = {
  dateRange: Range<Date>;
  accounts?: string[];
  categories?: number[];
  labels?: string[];
  recordTypes?: RecordType[];
  amountRange?: Partial<Range<number>>;
};

export type CreateTransactionOptions = Omit<Transaction, "id">;

export async function createTransaction(options: CreateTransactionOptions): Promise<Transaction> {
  await assertAccountExists(options.accountId);
  return feed.transactions.insert({
    id: generateRandomStringOfLength(10),
    accountId: options.accountId,
    type: options.type,
    category: options.category,
    amount: options.amount,
    direction: options.direction,
    note: options.note,
    labels: options.labels,
    timestamp: options.timestamp,
    isRecurringTransaction: options.isRecurringTransaction,
  }) as Transaction;
}

export async function getAllTransactions(options: GetAllTransactionsOptions): Promise<Transaction[]> {
  // TODO: add type safety here. target type: Record<subset of keys of Transaction, any>;
  const query: Record<string, any> = prepareQueryFromOptions(options);

  const transactions: Transaction[] = feed.transactions.chain().find(query).simplesort('timestamp').data();

  const recurringTransactions: RecurringTransaction[] = feed.recurringTransactions.find();
  const recurringTransactionsFlat: Transaction[] = await flattenRecurringTransactions(
    recurringTransactions,
    options.dateRange.from,
    options.dateRange.to,
  );
  return transactions.concat(recurringTransactionsFlat);
}

async function flattenRecurringTransactions(
  recurringTransactions: RecurringTransaction[],
  generateFrom: Date,
  generateTill: Date,
): Promise<Transaction[]> {
  let generatedTransactions: Transaction[] = [];
  for (let index = 0; index < recurringTransactions.length; index++) {
    const recurringTransaction = recurringTransactions[index];
    const transactions = flattenRecurringTransaction(recurringTransaction, generateFrom, generateTill);
    generatedTransactions = generatedTransactions.concat(transactions);
  }
  return generatedTransactions;
}

function flattenRecurringTransaction(recurringTransaction: RecurringTransaction, generateFrom: Date, generateTill: Date): Transaction[] {
  const cronExpr: string = recurringTransaction.cronExpr;

  const schedule: ScheduleData = later.parse.cron(cronExpr);

  let timestamps: Date[];
  if (recurringTransaction.endTokenType == EndRecurrenceBy.Count) {
    const count = recurringTransaction.endToken as number;
    timestamps = later.schedule(schedule).next(count, recurringTransaction.startDate) as Date[];
  } else if (recurringTransaction.endTokenType == EndRecurrenceBy.EndDate) {
    const endDate: Date = recurringTransaction.endToken as Date;
    timestamps = later.schedule(schedule).next(500, generateFrom, endDate) as Date[];
  } else if (recurringTransaction.endTokenType == EndRecurrenceBy.NeverEnd) {
    timestamps = later.schedule(schedule).next(500, generateFrom, generateTill) as Date[];
  } else {
    timestamps = [];
  }

  const generatedTransactions: Transaction[] = [];
  const utcGenerateFrom = generateFrom.getTime();
  const utcGenerateTill = generateTill.getTime();
  const recurringTransactionNote = '----\nAutogenerated by Wallet App.\n---';

  for (let index = 0; index < timestamps.length; index++) {
    const timestamp = timestamps[index];
    const utcTimestamp = timestamp.getTime();

    if (utcTimestamp > utcGenerateTill) break;
    else if (utcTimestamp < utcGenerateFrom) continue;

    generatedTransactions.push({
      id: generateRandomStringOfLength(10),
      accountId: recurringTransaction.accountId,
      type: recurringTransaction.type,
      category: recurringTransaction.category,
      amount: recurringTransaction.amount,
      direction: recurringTransaction.direction,
      note: recurringTransactionNote,
      labels: recurringTransaction.labels,
      timestamp: utcTimestamp,
      isRecurringTransaction: true,
    });
  }
  return generatedTransactions;
}

function prepareQueryFromOptions(options: GetAllTransactionsOptions) {
  const query: Record<string, any> = {
    '$and': [{'timestamp': {"$gte": options.dateRange.from.getTime()}},
        {'timestamp': {"$lte": options.dateRange.to.getTime()}}
    ]}

  if (options.accounts) {
    query.accountId = {
      "$in": options.accounts,
    };
  }
  if (options.categories) {
    query.category = {
      "$in": options.categories,
    };
  }

  return query;
}
